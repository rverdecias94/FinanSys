-- SKU system per area: prefixes mapping, sequential counter, trigger-based generation

-- 1) Prefix mapping table per area and user
CREATE TABLE IF NOT EXISTS inventory_area_prefixes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) NOT NULL,
  area_id BIGINT REFERENCES inventory_areas(id) ON DELETE CASCADE,
  prefix TEXT NOT NULL, -- 3-4 uppercase letters
  next_seq INTEGER NOT NULL DEFAULT 1,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE (user_id, area_id),
  UNIQUE (prefix) -- ensure global uniqueness to avoid collisions across system
);

CREATE INDEX IF NOT EXISTS idx_inventory_area_prefixes_user ON inventory_area_prefixes(user_id);
CREATE INDEX IF NOT EXISTS idx_inventory_area_prefixes_area ON inventory_area_prefixes(area_id);

ALTER TABLE inventory_area_prefixes ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Prefixes: select own" ON inventory_area_prefixes;
DROP POLICY IF EXISTS "Prefixes: insert own" ON inventory_area_prefixes;
DROP POLICY IF EXISTS "Prefixes: update own" ON inventory_area_prefixes;
DROP POLICY IF EXISTS "Prefixes: delete own" ON inventory_area_prefixes;

CREATE POLICY "Prefixes: select own" ON inventory_area_prefixes
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Prefixes: insert own" ON inventory_area_prefixes
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Prefixes: update own" ON inventory_area_prefixes
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Prefixes: delete own" ON inventory_area_prefixes
  FOR DELETE USING (auth.uid() = user_id);

-- 2) Add SKU column to items and enforce uniqueness globally
ALTER TABLE inventory_items ADD COLUMN IF NOT EXISTS sku TEXT;
CREATE UNIQUE INDEX IF NOT EXISTS idx_inventory_items_sku_unique ON inventory_items(sku);

-- 3) RPC function to generate SKU and insert item atomically (safer with RLS)
CREATE OR REPLACE FUNCTION public.create_inventory_item(p_user UUID, p_area BIGINT, p_values JSONB)
RETURNS inventory_items AS $$
DECLARE
  v_prefix TEXT;
  v_seq INTEGER;
  v_sku TEXT;
  v_item inventory_items;
BEGIN
  IF p_area IS NULL OR p_user IS NULL THEN
    RAISE EXCEPTION 'area_id and user_id are required to generate SKU';
  END IF;

  -- Lock the prefix row to handle concurrency and increment safely
  SELECT prefix, next_seq INTO v_prefix, v_seq
  FROM inventory_area_prefixes
  WHERE area_id = p_area AND user_id = p_user
  FOR UPDATE;

  IF v_prefix IS NULL THEN
    RAISE EXCEPTION 'SKU prefix not configured for area % and user %', p_area, p_user;
  END IF;

  v_sku := v_prefix || '-' || LPAD(v_seq::text, 4, '0');

  -- Advance sequence
  UPDATE inventory_area_prefixes
    SET next_seq = v_seq + 1
  WHERE area_id = p_area AND user_id = p_user;

  -- Insert item
  INSERT INTO inventory_items (user_id, area_id, values, sku)
  VALUES (p_user, p_area, p_values, v_sku)
  RETURNING * INTO v_item;

  RETURN v_item;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION public.create_inventory_item(UUID, BIGINT, JSONB) TO authenticated;

-- 5) Helper RPC: generate SKU (returns TEXT) without inserting item
CREATE OR REPLACE FUNCTION public.generate_inventory_sku(p_user UUID, p_area BIGINT)
RETURNS TEXT AS $$
DECLARE
  v_prefix TEXT;
  v_seq INTEGER;
  v_sku TEXT;
  v_src TEXT;
BEGIN
  IF p_area IS NULL OR p_user IS NULL THEN
    RAISE EXCEPTION 'area_id and user_id are required to generate SKU';
  END IF;

  -- Try to lock existing prefix row
  SELECT prefix, next_seq INTO v_prefix, v_seq
  FROM inventory_area_prefixes
  WHERE area_id = p_area AND user_id = p_user
  FOR UPDATE;

  -- If not configured, derive a professional default from area slug/name and create mapping
  IF v_prefix IS NULL THEN
    SELECT COALESCE(NULLIF(slug, ''), name) INTO v_src
    FROM inventory_areas
    WHERE id = p_area AND user_id = p_user;

    IF v_src IS NULL THEN
      v_prefix := 'AR' || LPAD(p_area::text, 2, '0');
    ELSE
      -- Clean and take first up to 4 alphanumeric chars
      v_src := upper(regexp_replace(v_src, '[^A-Za-z0-9]', '', 'g'));
      v_prefix := substring(v_src from 1 for 4);
      IF v_prefix IS NULL OR length(v_prefix) < 2 THEN
        v_prefix := 'AR' || LPAD(p_area::text, 2, '0');
      END IF;
    END IF;

    INSERT INTO inventory_area_prefixes(user_id, area_id, prefix, next_seq)
    VALUES (p_user, p_area, v_prefix, 1)
    ON CONFLICT (user_id, area_id) DO NOTHING;

    -- Lock again to get current sequence
    SELECT prefix, next_seq INTO v_prefix, v_seq
    FROM inventory_area_prefixes
    WHERE area_id = p_area AND user_id = p_user
    FOR UPDATE;
  END IF;

  v_sku := v_prefix || '-' || LPAD(v_seq::text, 4, '0');

  -- Advance sequence
  UPDATE inventory_area_prefixes
    SET next_seq = v_seq + 1
  WHERE area_id = p_area AND user_id = p_user;

  RETURN v_sku;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION public.generate_inventory_sku(UUID, BIGINT) TO authenticated;

-- NOTIFY PostgREST to reload schema cache
NOTIFY pgrst, 'reload schema';
