-- 0. PRE-CLEANUP: Remove objects from previous failed runs or incorrect configurations
-- We must DROP POLICIES dependent on the column BEFORE dropping the column itself.

-- Cleanup product_categories policies (user isolation ones we want to remove)
DROP POLICY IF EXISTS "Users can view their own categories" ON product_categories;
DROP POLICY IF EXISTS "Users can insert their own categories" ON product_categories;
DROP POLICY IF EXISTS "Users can update their own categories" ON product_categories;
DROP POLICY IF EXISTS "Users can delete their own categories" ON product_categories;

-- Cleanup index on product_categories
DROP INDEX IF EXISTS idx_product_categories_user_id;

-- Cleanup column on product_categories
ALTER TABLE product_categories DROP COLUMN IF EXISTS user_id;


-- 1. Add user_id column to products (but NOT categories as they are shared)
ALTER TABLE products 
ADD COLUMN IF NOT EXISTS user_id UUID REFERENCES auth.users(id);

-- 2. Create Indexes for performance
CREATE INDEX IF NOT EXISTS idx_products_user_id ON products(user_id);
CREATE INDEX IF NOT EXISTS idx_movements_user_id ON movements(user_id);


-- 3. Create Security Audit Log Table
CREATE TABLE IF NOT EXISTS access_audit_logs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id),
  action TEXT NOT NULL,
  resource TEXT NOT NULL,
  details JSONB,
  ip_address TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

ALTER TABLE access_audit_logs ENABLE ROW LEVEL SECURITY;

-- Drop existing policies for audit logs to ensure idempotency
DROP POLICY IF EXISTS "Users can insert their own logs" ON access_audit_logs;
DROP POLICY IF EXISTS "Users can view their own logs" ON access_audit_logs;

CREATE POLICY "Users can insert their own logs" ON access_audit_logs
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can view their own logs" ON access_audit_logs
  FOR SELECT USING (auth.uid() = user_id);


-- 4. Update RLS Policies for STRICT ISOLATION

-- Products
DROP POLICY IF EXISTS "Enable all access for authenticated users on products" ON products;

-- Drop new policies if they exist (to avoid duplication errors on rerun)
DROP POLICY IF EXISTS "Users can view their own products" ON products;
DROP POLICY IF EXISTS "Users can insert their own products" ON products;
DROP POLICY IF EXISTS "Users can update their own products" ON products;
DROP POLICY IF EXISTS "Users can delete their own products" ON products;

CREATE POLICY "Users can view their own products" ON products
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own products" ON products
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own products" ON products
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own products" ON products
  FOR DELETE USING (auth.uid() = user_id);

-- Movements
DROP POLICY IF EXISTS "Enable all access for authenticated users on movements" ON movements;

-- Drop new policies if they exist
DROP POLICY IF EXISTS "Users can view their own movements" ON movements;
DROP POLICY IF EXISTS "Users can insert their own movements" ON movements;
DROP POLICY IF EXISTS "Users can update their own movements" ON movements;
DROP POLICY IF EXISTS "Users can delete their own movements" ON movements;

CREATE POLICY "Users can view their own movements" ON movements
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own movements" ON movements
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own movements" ON movements
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own movements" ON movements
  FOR DELETE USING (auth.uid() = user_id);

-- Categories (Ensure they remain shared/global for authenticated users)
DROP POLICY IF EXISTS "Enable read access for authenticated users on product_categories" ON product_categories;

CREATE POLICY "Enable read access for authenticated users on product_categories" ON product_categories
  FOR SELECT USING (auth.role() = 'authenticated');
